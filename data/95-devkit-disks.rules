# Do not edit this file, it will be overwritten on updates
#

# import names for PCI storage controllers
#
SUBSYSTEMS=="pci", ENV{ID_MODEL_FROM_DATABASE}=="", ATTR{class}="0x01*", IMPORT{program}="pci-db %p"

##############################################################################################################

# from here on, we only care about block devices
ACTION!="add|change", GOTO="devkit_disks_end"
SUBSYSTEM!="block", GOTO="devkit_disks_end"
KERNEL=="loop*|ram*", GOTO="devkit_disks_end"

# Mark devices that shouldn't be automounted / autoassembled etc.
#
# Deny all, then punch holes for what looks like physical drives
# (TODO: this heuristic might need some work)
#

ENV{DKD_PRESENTATION_NOPOLICY}="1"
KERNEL=="sd*|hd*|sr*|mmcblk*|mspblk*", ENV{DKD_PRESENTATION_NOPOLICY}="0"

##############################################################################################################

# we only care about change events on device-mapper
# devices - never touch the device on add events
KERNEL=="dm-*", ACTION!="change", GOTO="devkit_disks_end"

# honor the flag that device-mapper sets if the device should be ignored
ENV{DM_UDEV_DISABLE_OTHER_RULES_FLAG}=="1", GOTO="devkit_disks_end"

# ignore private devices - see https://bugzilla.redhat.com/show_bug.cgi?id=528909#c24
KERNEL=="dm-*", IMPORT{program}="devkit-disks-dm-export %M %m"
ENV{DKD_DM_UUID}=="CRYPT-TEMP-?*", GOTO="devkit_disks_end"
ENV{DKD_DM_UUID}!="?*", ENV{DKD_DM_NAME}=="temporary-cryptsetup-?*", GOTO="devkit_disks_end"
ENV{DKD_DM_NAME}=="?*-pvmove[0-9]*", GOTO="devkit_disks_end"

##############################################################################################################

# Probe for partition tables; this really should be part of udev
#

# skip rules for inappropriate block devices
KERNEL=="fd*|mtd*|nbd*|gnbd*|btibm*", GOTO="probe_parttable_end"

# never access non-cdrom removable ide devices, the drivers are causing event loops on open()
KERNEL=="hd*[!0-9]", ATTR{removable}=="1", SUBSYSTEMS=="ide", ATTRS{media}=="disk|floppy", GOTO="probe_parttable_end"
KERNEL=="hd*[0-9]", ATTR{removable}=="1", GOTO="probe_parttable_end"

# don't scan for partition tables on empty discs
KERNEL=="sr*", ENV{ID_CDROM_MEDIA}!="?*", GOTO="probe_parttable_end"

# scan for partition tables both on whole-disk and partitions
#
IMPORT{program}="devkit-disks-part-id $tempnode"

LABEL="probe_parttable_end"

##############################################################################################################

# pick up device-mapper data; this REALLY should be done by rules installed
# by the device-mapper package
#
KERNEL!="dm-*", GOTO="device_mapper_end"
ACTION!="change", GOTO="device_mapper_end"

ENV{DKD_DM_NAME}!="?*", GOTO="device_mapper_end"

ENV{DKD_DM_STATE}=="SUSPENDED", GOTO="device_mapper_end"
ENV{DKD_DM_TARGET_TYPES}=="|*error*", GOTO="device_mapper_end"

# avoid probing if it has already been done earlier
#
ENV{ID_FS_USAGE}!="", GOTO="device_mapper_end"
IMPORT{program}="/sbin/blkid -o udev -p $tempnode"

LABEL="device_mapper_end"

##############################################################################################################

# pick up data from MD components; this REALLY should be done by rules installed
# by mdadm or the kernel package
#
ENV{ID_FS_TYPE}!="linux_raid_member", GOTO="md_end"

# avoid probing if it has already been done earlier
#
ENV{MD_LEVEL}!="", GOTO="md_end"
IMPORT{program}="/sbin/mdadm --examine --export $tempnode"

LABEL="md_end"

##############################################################################################################

# Check if a disk is ATA SMART capable
#

# USB ATA enclosures with a SAT layer
KERNEL=="sd*[!0-9]", ATTR{removable}=="0", ENV{ID_BUS}=="usb", ENV{DEVTYPE}=="disk", IMPORT{program}="devkit-disks-probe-ata-smart $tempnode"

# ATA disks driven by libata
KERNEL=="sd*[!0-9]", ATTR{removable}=="0", ENV{ID_BUS}=="ata", ENV{DEVTYPE}=="disk", IMPORT{program}="devkit-disks-probe-ata-smart $tempnode"

# ATA disks connected via SAS (not driven by libata)
KERNEL=="sd*[!0-9]", ATTR{removable}=="0", ENV{ID_BUS}=="scsi", ENV{DEVTYPE}=="disk", ENV{ID_VENDOR}=="ATA", IMPORT{program}="devkit-disks-probe-ata-smart $tempnode"

##############################################################################################################

# Example rule for tagging a device with a specific media type. Where and
# how to store this database needs some thought.
#
ATTRS{idVendor}=="050d", ATTRS{idProduct}=="0248", ENV{ID_INSTANCE}=="0:0", ENV{ID_DRIVE_FLASH_CF}="1"
ATTRS{idVendor}=="050d", ATTRS{idProduct}=="0248", ENV{ID_INSTANCE}=="0:1", ENV{ID_DRIVE_FLASH_MS}="1"
ATTRS{idVendor}=="050d", ATTRS{idProduct}=="0248", ENV{ID_INSTANCE}=="0:2", ENV{ID_DRIVE_FLASH_SM}="1"
ATTRS{idVendor}=="050d", ATTRS{idProduct}=="0248", ENV{ID_INSTANCE}=="0:3", ENV{ID_DRIVE_FLASH_SD}="1"

ATTRS{idVendor}=="05e3", ATTRS{idProduct}=="070e", ENV{ID_INSTANCE}=="0:0", ENV{ID_DRIVE_FLASH_CF}="1"
ATTRS{idVendor}=="05e3", ATTRS{idProduct}=="070e", ENV{ID_INSTANCE}=="0:1", ENV{ID_DRIVE_FLASH_SM}="1"
ATTRS{idVendor}=="05e3", ATTRS{idProduct}=="070e", ENV{ID_INSTANCE}=="0:2", ENV{ID_DRIVE_FLASH_SD}="1"
ATTRS{idVendor}=="05e3", ATTRS{idProduct}=="070e", ENV{ID_INSTANCE}=="0:3", ENV{ID_DRIVE_FLASH_MS}="1"

# Generic music player
#
ENV{ID_MEDIA_PLAYER}=="?*", ENV{DKD_PRESENTATION_ICON_NAME}="multimedia-player"

# Apple iPod Video
#
ATTRS{idVendor}=="05ac", ATTRS{idProduct}=="1209", ENV{DKD_PRESENTATION_ICON_NAME}="multimedia-player-ipod-white"

##############################################################################################################

# PC floppy drives
#
KERNEL=="fd*", ENV{ID_DRIVE_FLOPPY}="1"

# USB floppy drives
#
ATTRS{bInterfaceClass}=="08", ATTRS{bInterfaceSubClass}=="04", ENV{ID_DRIVE_FLOPPY}="1"

# ATA Zip drives
#
ENV{ID_VENDOR}=="*IOMEGA*", ENV{ID_MODEL}=="*ZIP*", ENV{ID_DRIVE_FLOPPY_ZIP}="1"

##############################################################################################################

# Partitions which desktops should not display
#

# Apple Bootstrap partitions
ENV{DKD_PARTITION_SCHEME}=="apm", ENV{DKD_PARTITION_TYPE}=="Apple_Bootstrap", ENV{DKD_PRESENTATION_HIDE}="1"

# special MBR partition types (EFI, hidden, etc.)
# see http://www.win.tue.nl/~aeb/partitions/partition_types-1.html
ENV{DKD_PARTITION_SCHEME}=="mbr", \
  ENV{DKD_PARTITION_TYPE}=="0x00|0x11|0x14|0x16|0x17|0x1b|0x1c|0x1e|0x27|0x3d|0x84|0x8d|0x90|0x91|0x92|0x93|0x97|0x98|0x9a|0x9b|0xbb|0xc2|0xc3|0xdd|0xef", \
  ENV{DKD_PRESENTATION_HIDE}="1"

# special GUID-identified partition types
# see http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
ENV{DKD_PARTITION_SCHEME}=="gpt", \
  ENV{DKD_PARTITION_TYPE}=="C12A7328-F81F-11D2-BA4B-00A0C93EC93B|21686148-6449-6E6F-744E-656564454649", \
  ENV{DKD_PRESENTATION_HIDE}="1"

# recovery partitions (taken from old hal rules)
ENV{ID_FS_TYPE}=="ntfs|vfat", \
  ENV{ID_FS_LABEL}=="RECOVERY|HP_RECOVERY|Recovery Partition|DellUtility|DellRestore|IBM_SERVICE|SERVICEV001|SERVICEV002", \
  ENV{DKD_PRESENTATION_HIDE}="1"

##############################################################################################################


LABEL="devkit_disks_end"
