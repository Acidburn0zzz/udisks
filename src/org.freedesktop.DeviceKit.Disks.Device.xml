<!DOCTYPE node PUBLIC
"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
<node name="/">

  <interface name="org.freedesktop.DeviceKit.Disks.Device">

    <!-- BEGIN LIST OF METHODS -->

    <!-- TODO: docs -->
    <method name="UnlockEncrypted">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="secret" direction="in" type="s"/>
      <arg name="options" direction="in" type="as"/>
      <arg name="cleartext_device" direction="out" type="o"/>
    </method>

    <!-- TODO: docs -->
    <method name="LockEncrypted">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as"/>
    </method>

    <!-- TODO: docs -->
    <method name="ChangeSecretForEncrypted">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="current_secret" direction="in" type="s"/>
      <arg name="new_secret" direction="in" type="s"/>
    </method>

    <!-- TODO: docs -->
    <method name="Mount">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="filesystem_type" direction="in" type="s"/>
      <arg name="options" direction="in" type="as"/>
      <arg name="mount_path" direction="out" type="s"/>
    </method>

    <!-- TODO: docs -->
    <method name="CancelJob">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
    </method>

    <!-- TODO: docs -->
    <method name="Unmount">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as"/>
    </method>

    <!-- TODO: docs -->
    <method name="Erase">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as"/>
    </method>

    <!-- StopLinuxMdArray:
         @options:   Options for stopping the array. Currently
                     this is unused, no options are supported.

         Stops a Linux md RAID array.
      -->
    <method name="StopLinuxMdArray">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as"/>
    </method>

    <!-- RetrieveSmartData:

         Retrieves S.M.A.R.T. data from the drive.

         TODO: We probably should return all attributes or something
               more detailed. And at the same time try to abstract
               the difference between SCSI and ATA.

         Returns: Whether the drive is healthy, the number of hours
                  it's been powered and the temperature in Celcius.
      -->
    <method name="RetrieveSmartData">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>

      <arg name="is_healthy" direction="out" type="b"/>
      <arg name="power_on_hours" direction="out" type="i"/>
      <arg name="temperature" direction="out" type="i"/>
    </method>


    <!-- RunSmartSelftest:

         @test:     The name of the test to run; supported values
                    are 'short' (usually less than ten minutes)
                    and 'long' (usually tens of minutes) and
                    'conveyance' (usually a few minutes). See the
                    smartctl(1) man page for details.

         @captive:  If set to #TRUE then the drive will block
                    access to the drive for the duration of the
                    test. The method will error out if the drive
                    is busy, e.g. if partitions are mounted.

         Runs a S.M.A.R.T. self test on the drive.

         TODO: need to figure out whether we need a return code

      -->
    <method name="RunSmartSelftest">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>

      <arg name="test" direction="in" type="s"/>
      <arg name="captive" direction="in" type="b"/>
    </method>


    <!-- CreatePartitionTable:
         @scheme:   The type of partition table to create. Currently
                    the types 'none', 'mbr', 'gpt' and 'apm' are
                    supported.

         @options:  Supported options are:
                     - erase=: whether to erase the contents of the
                               device before creating a new partition
                               table. Valid values include "none",
                               "full", "full7pass" and "full35pass".

         Creates a new partition table. Optionally deletes all data
         on the device before doing so.
      -->
    <method name="CreatePartitionTable">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="scheme" direction="in" type="s"/>
      <arg name="options" direction="in" type="as"/>
    </method>

    <!-- DeletePartition:

         @options:  Supported options are:
                     - erase=: whether to erase the contents of the
                               partition before deleting the entry.
                               Valid values include "none", "full",
                               "full7pass" and "full35pass".

         Deletes an entry from the partition table; optionally
         erasing the space before doing so.
      -->
    <method name="DeletePartition">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as"/>
    </method>

    <!-- ModifyPartition:
         @type:      The type of the partition to create. Depends
                     on the partitioning scheme.

         @label:     The label to use for the partition. Leave
                     blank if the partition table scheme doesn't
                     support labels.

         @flags:     Flags to use for the partition. (TODO)

         Modifies the meta data such as label and flags for a
         partition.

         TODO: Consider allowing changing offset and size. Or
               maybe that should be a separate method.
      -->
    <method name="ModifyPartition">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="type" direction="in" type="s"/>
      <arg name="label" direction="in" type="s"/>
      <arg name="flags" direction="in" type="as"/>
    </method>

    <!-- CreatePartition:
         @offset:    Where to create the partition.

         @size:      Size of the partitition to create.

         @type:      The type of the partition to create. Depends
                     on the partitioning scheme.

         @label:     The label to use for the partition. Leave
                     blank if the partition table scheme doesn't
                     support labels.

         @flags:     Flags to use for the partition. (TODO)

         @options:   Options for partition creation. Currently
                     this is unused, no options are supported.

         @fstype:    The file system to create in new partition. Leave
                     blank to skip creating a file system. See the
                     CreateFilesystem() method for details.

         @fsoptions: Options to use for file system creation. See
                     the CreateFilesystem() method for details.

         Create a new partition and, optionally, create a file system
         on it. The partition won't necessarily be created at the
         exact location requested.

         Returns: the object path of the newly added partition.
      -->
    <method name="CreatePartition">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="offset" direction="in" type="t"/>
      <arg name="size" direction="in" type="t"/>
      <arg name="type" direction="in" type="s"/>
      <arg name="label" direction="in" type="s"/>
      <arg name="flags" direction="in" type="as"/>
      <arg name="options" direction="in" type="as"/>
      <arg name="fstype" direction="in" type="s"/>
      <arg name="fsoptions" direction="in" type="as"/>

      <arg name="created_device" direction="out" type="o"/>
    </method>

    <!-- CreateFilesystem:
         @fstype:   the of file system to create. Pass "empty" to
                    not create a file system. Use @TODO@ to get
                    a list of file systems that can be created.

         @options:  List of options. Known options that are file system
                    independent are:

                     - label=:   For setting the file system label. May not
                                 be support for all file systems and the
                                 allowed length varies. See @TODO@ for the
                                 file systems supported by the system.

                     - erase=:   whether to erase the device before
                                 creating a file system. Valid values
                                 include "none", "full", "full7pass" and
                                 "full35pass".

                     - encrypt=: If this option is used, the file system
                                 will be created on an encrypted block device
                                 that will be setup. The passphrase used is
                                 the value following the '=' character.

         Create a file system on a device.
     -->
    <method name="CreateFilesystem">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="fstype" direction="in" type="s"/>
      <arg name="options" direction="in" type="as"/>
    </method>

    <!-- ChangeFilesystemLabel:
         @new_label:   The new label to use

         Changes the file system label.
      -->
    <method name="ChangeFilesystemLabel">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="new_label" direction="in" type="s"/>
    </method>

    <!-- BEGIN LIST OF SIGNALS -->

    <!-- Something about the device changed. Changes in job state
         wont trigger this signal; see the 'JobChanged' signal -->
    <signal name="Changed"/>

    <!-- Job state changed; clients should listen to this signal
         to avoid polling the daemon for job state -->
    <signal name="JobChanged">
      <arg name="job-in-progress" type="b"/>
      <arg name="job-is-cancellable" type="b"/>
      <arg name="job-id" type="s"/>
      <arg name="job-num-tasks" type="i"/>
      <arg name="job-cur-task" type="i"/>
      <arg name="job-cur-task-id" type="s"/>
      <arg name="job-cur-task-percentage" type="d"/>
    </signal>

    <!-- BEGIN LIST OF PROPERTIES

         A general note about properties: the set of values returned
         can be expected to grow in the future as hardware evolves.
         Care has been taken to both namespace some values (so
         applications can make educated guesses) and export both
         general and specific properties (such as id_usage
         vs. id_type).

         In general an empty string properties means "not set"; as the
         empty string "" is not a valid object we use the object path
         "/" to mean "not set" for object paths. -->

    <!-- The 'native-path' property is the OS native path for the
         device; on Linux this is the sysfs path.

         The 'device-is-busy' property is set if the device is
         in use; this can hapen if it's mounted, if another
         block device is claiming it (e.g. a RAID drive) or if a
         job initiated from DeviceKit-disks is pending.
      -->
    <property name="native-path" type="s" access="read"/>
    <property name="device-file" type="s" access="read"/>
    <property name="device-file-by-id" type="as" access="read"/>
    <property name="device-file-by-path" type="as" access="read"/>
    <property name="device-is-partition" type="b" access="read"/>
    <property name="device-is-partition-table" type="b" access="read"/>
    <property name="device-is-removable" type="b" access="read"/>
    <property name="device-is-media-available" type="b" access="read"/>
    <property name="device-is-read-only" type="b" access="read"/>
    <property name="device-is-drive" type="b" access="read"/>
    <property name="device-is-mounted" type="b" access="read"/>
    <property name="device-is-crypto-cleartext" type="b" access="read"/>
    <property name="device-is-busy" type="b" access="read"/>
    <property name="device-is-linux-md-component" type="b" access="read"/>
    <property name="device-is-linux-md" type="b" access="read"/>
    <property name="device-mount-path" type="s" access="read"/>
    <property name="device-size" type="t" access="read"/>
    <property name="device-block-size" type="t" access="read"/>

    <!-- The job properties specify if a job initiated via the
         DeviceKit-disks daemon is currently in progress.  A job may
         be split into several sequential tasks; in that case
         'job-num-tasks' will be greater than zero. If it is 0 none
         of the 'job-cur-*' properties will be set.

         The 'job-id' property is used to identify the job and maps
         1-1 with the names of the method calls on this interface,
         e.g. 'Erase', 'CreateFilesystem' and so on.

         Note that the 'job-cur-task' percentage starts at 0.  The
         percentage is normally a number between 0 and 100. If set to -1
         it means the progress of the current is unknown. The task id is
         a well-defined name defining the current subtask of the job;
         known tasks id's are

          - zeroing: zeroing data on the device
          - sync:    flushing data to the device
          - mkfs:    creating file system
      -->
    <property name="job-in-progress" type="b" access="read"/>
    <property name="job-id" type="s" access="read"/>
    <property name="job-is-cancellable" type="b" access="read"/>
    <property name="job-num-tasks" type="i" access="read"/>
    <property name="job-cur-task" type="i" access="read"/>
    <property name="job-cur-task-id" type="s" access="read"/>
    <property name="job-cur-task-percentage" type="d" access="read"/>

    <!-- the usage is a result of probing for signatures on the block
         device; known values are

           filesystem      - the device contains a file system; known
                             values for 'id-type' is the same as the
                             name of the OS fs driver e.g. 'vfat',
                             'ext3' and so on.

           crypto          - the device contains encrypted data. Known
                             values for 'id-type' are 'crypto_LUKS'.

           partitiontable  - the device is partitioned into other devices.
                             Known values for 'id-type' are
                              mbr  - Master Boot Record
                              embr - Extended Master Boot Record
                              apm  - Apple Partitoning Map
                              gpt  - GUID Partition Table

           raid            - the device is member of a RAID set or another
                             scheme that requires device assembly. Known
                             values for 'id-type' are TODO.

           other           - other signature found on the device

         The 'id-uuid' and 'id-label' properties, if set, are dependent
         on the 'id-type' property -->
    <property name="id-usage" type="s" access="read"/>
    <property name="id-type" type="s" access="read"/>
    <property name="id-version" type="s" access="read"/>
    <property name="id-uuid" type="s" access="read"/>
    <property name="id-label" type="s" access="read"/>

    <!-- The following properties are only set if the device is
         a clear text device for an encrypted block device (see
         the property 'device-is-crypto-cleartext').

         The property 'crypto-cleartext-slave' is a reference to the
         encrypted block device.
      -->
    <property name="crypto-cleartext-slave" type="o" access="read"/>

    <!-- the following properties are only set if the device is
         a partition (see 'device-is-partition'). Known values
         for the partitioning scheme are

           mbr  - Master Boot Record
           embr - Extended Master Boot Record
           apm  - Apple Partitoning Map
           gpt  - GUID Partition Table

         The 'partition-slave' property specifies what device
         the device in question is a partition of. The property
         'partition-number' is the number of the partition starting
         from 1 -->
    <property name="partition-slave" type="o" access="read"/>
    <property name="partition-scheme" type="s" access="read"/>
    <property name="partition-type" type="s" access="read"/>
    <property name="partition-label" type="s" access="read"/>
    <property name="partition-uuid" type="s" access="read"/>
    <property name="partition-flags" type="as" access="read"/>
    <property name="partition-number" type="i" access="read"/>
    <property name="partition-offset" type="t" access="read"/>
    <property name="partition-size" type="t" access="read"/>

    <!-- the type of partition table the deice contains; only set if
         'device-is-partition-table' is true. Known values are

           mbr  - Master Boot Record
           embr - Extended Master Boot Record
           apm  - Apple Partitoning Map
           gpt  - GUID Partition Table

         The 'partition-table-count' property specifies the number
         of partitions in the partition table. Note that the
         partitions may not be sequentially numbered (e.g.
         it's fine for 'partition-table-count' to report 2
         and 'partition-number' for the associated paritions
         report 1 resp. 4). The property 'partition-table-max-number'
         will contain the maximum value for 'partition-number'
         of any partitions.

         The 'partition-table-offsets' and 'partition-table-sizes'
         properties are arrays indexed by 'partition-number' and
         are of size 'partition-table-max-number'. It may contain
         holes in which case the offset will be 0. -->
    <property name="partition-table-scheme" type="s" access="read"/>
    <property name="partition-table-count" type="i" access="read"/>
    <property name="partition-table-max-number" type="i" access="read"/>
    <property name="partition-table-offsets" type="ai" access="read"/>
    <property name="partition-table-sizes" type="ai" access="read"/>

    <!-- Properties for the drive. The property drive-connection-interface
         specifies the physical connection used to connect the drive (or
         it's enclosure) to the host system.

         (TODO: actually, on Linux, it's hard to get the kernel/driver
         to tell us this; in fact it might not even be possible as the
         device driver itself may not know. Need to investigate this;
         what we want to achieve here is making it easy for end users to
         know what kind of drive to buy when getting a replacement drive.
         And painting a nice icon.)

         Known values for drive-connection-interface include

          virtual            - a virtual device such as a software
                               RAID array or LVM device
          ata                - connected via ATA (PATA)
          ata_serial         - connected via Serial ATA (SATA)
          ata_serial_esata   - connected via External Serial ATA (eSATA)
          ata_parallel       - connected via Parallel ATA
          scsi               - connected via SCSI
          usb                - connected via USB
          firewire           - connected via Firewire

         The property drive-connection-speed specifies the nominal
         maximum speed of the interface in bits/s; if unknown this
         is set to 0.

         The drive-media-compatibility property specifies what kind of
         media can be used in the drive (it's an array of strings); this is
         sometimes set using quirk files if the hardware isn't capable of
         precisely reporting it. The property drive-media specifies the
         current type of media in the drive.

         Known values for drive-media-compatibility and drive-media include

           flash
           flash_cf
           flash_ms
           flash_sm
           flash_sd
           flash_sdhc
           flash_mmc
           floppy
           floppy_zip
           floppy_jaz
           optical
           optical_cd
           optical_cd_r
           optical_cd_rw
           optical_dvd
           optical_dvd_r
           optical_dvd_rw
           optical_dvd_ram
           optical_dvd_plus_r
           optical_dvd_plus_rw
           optical_dvd_plus_r_dl
           optical_dvd_plus_rw_dl
           optical_bd
           optical_bd_r
           optical_bd_re
           optical_hddvd
           optical_hddvd_r
           optical_hddvd_rw
           optical_mo
           optical_mrw
           optical_mrw_w

      -->
    <property name="drive-vendor" type="s" access="read"/>
    <property name="drive-model" type="s" access="read"/>
    <property name="drive-revision" type="s" access="read"/>
    <property name="drive-serial" type="s" access="read"/>
    <property name="drive-connection-interface" type="s" access="read"/>
    <property name="drive-connection-speed" type="t" access="read"/>
    <property name="drive-media-compatibility" type="as" access="read"/>
    <property name="drive-media" type="s" access="read"/>

    <!-- The device is a component of a Linux MD (Software RAID) array;
         see property device-is-linux-md-component
      -->
    <property name="linux-md-component-level" type="i" access="read"/>
    <property name="linux-md-component-num-raid-devices" type="i" access="read"/>
    <property name="linux-md-component-uuid" type="s" access="read"/>
    <property name="linux-md-component-name" type="s" access="read"/>
    <property name="linux-md-component-version" type="s" access="read"/>

    <!-- The device is a Linux MD (Software RAID) array. The components
         of the array are in the linux-md-slaves property.
      -->
    <property name="linux-md-level" type="i" access="read"/>
    <property name="linux-md-num-raid-devices" type="i" access="read"/>
    <property name="linux-md-uuid" type="s" access="read"/>
    <property name="linux-md-name" type="s" access="read"/>
    <property name="linux-md-version" type="s" access="read"/>
    <property name="linux-md-slaves" type="ao" access="read"/>

  </interface>

</node>
