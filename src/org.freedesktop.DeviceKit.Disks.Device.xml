<!DOCTYPE node PUBLIC
"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd" [
  <!ENTITY ERROR_FAILED "org.freedesktop.DeviceKit.Disks.Error.Failed">
  <!ENTITY ERROR_INHIBITED "org.freedesktop.DeviceKit.Disks.Error.Inhibited">
  <!ENTITY ERROR_BUSY "org.freedesktop.DeviceKit.Disks.Error.Busy">
  <!ENTITY ERROR_CANCELLED "org.freedesktop.DeviceKit.Disks.Error.Cancelled">
  <!ENTITY ERROR_INVALID_OPTION "org.freedesktop.DeviceKit.Disks.Error.InvalidOption">
  <!ENTITY ERROR_ALREADY_MOUNTED "org.freedesktop.DeviceKit.Disks.Error.AlreadyMounted">
  <!ENTITY ERROR_NOT_MOUNTED "org.freedesktop.DeviceKit.Disks.Error.NotMounted">
  <!ENTITY ERROR_NOT_CANCELLABLE "org.freedesktop.DeviceKit.Disks.Error.NotCancellable">
  <!ENTITY ERROR_NOT_PARTITION "org.freedesktop.DeviceKit.Disks.Error.NotPartition">
  <!ENTITY ERROR_NOT_PARTITION_TABLE "org.freedesktop.DeviceKit.Disks.Error.NotPartitionTable">
  <!ENTITY ERROR_NOT_FILESYSTEM "org.freedesktop.DeviceKit.Disks.Error.NotFilesystem">
  <!ENTITY ERROR_NOT_LUKS "org.freedesktop.DeviceKit.Disks.Error.NotLuks">
  <!ENTITY ERROR_NOT_LOCKED "org.freedesktop.DeviceKit.Disks.Error.NotLocked">
  <!ENTITY ERROR_NOT_UNLOCKED "org.freedesktop.DeviceKit.Disks.Error.NotUnlocked">
  <!ENTITY ERROR_NOT_LINUX_MD "org.freedesktop.DeviceKit.Disks.Error.NotLinuxMd">
  <!ENTITY ERROR_NOT_LINUX_MD_COMPONENT "org.freedesktop.DeviceKit.Disks.Error.NotLinuxMdComponent">
  <!ENTITY ERROR_NOT_DRIVE "org.freedesktop.DeviceKit.Disks.Error.NotDrive">
  <!ENTITY ERROR_NOT_SUPPORTED "org.freedesktop.DeviceKit.Disks.Error.NotSupported">
  <!ENTITY ERROR_NOT_FOUND "org.freedesktop.DeviceKit.Disks.Error.NotFound">
  <!ENTITY ERROR_ATA_SMART_NOT_AVAILABLE "org.freedesktop.DeviceKit.Disks.Error.AtaSmartNotAvailable">
  <!ENTITY ERROR_ATA_SMART_WOULD_WAKEUP "org.freedesktop.DeviceKit.Disks.Error.AtaSmartWouldWakeup">
  <!ENTITY ERROR_NOT_AUTHORIZED "org.freedesktop.PolicyKit.Error.NotAuthorized">
]>
<node name="/" xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
  <interface name="org.freedesktop.DeviceKit.Disks.Device">
    <doc:doc>
      <doc:description>
        <doc:para>
          This interface provides information about a block device on
          a UNIX-like system. In addition to just providing
          information, methods can be invoked to perform operations on
          the block device. Objects implementing this interface have
          object paths prefixed with <doc:tt>/devices/</doc:tt>
          followed by a sanitized representation of the base name of
          their native path. As the D-Bus specification greatly limits
          what characters can be used in object paths, this doesn't
          necessarily map one to one with the native basename; for
          example the native
          path <doc:tt>/sys/devices/virtual/block/dm-0</doc:tt> will
          be represented as <doc:tt>/devices/dm_0</doc:tt>.
        </doc:para>
        <doc:para>
          Most methods on this interface take an array of strings
          for options that can affect what the method does. Some of
          these options are literal strings (such
          as <doc:tt>noatime</doc:tt>) while some are encoded in the
          form of a key/value pair (such
          as <doc:tt>label=</doc:tt>). While the documentation for
          each method will specify exactly what set of options are
          recognized, many methods accepts
          the <doc:tt>erase=</doc:tt> option that can be used to
          erase the contents of the device prior to starting the
          operation. Instead of repeating what values can be used in
          the the <doc:tt>erase=</doc:tt> option in every method
          that supports it, we will enumerate them only once:
          <doc:list>
            <doc:item>
              <doc:term>none</doc:term>
              <doc:definition>Only areas of the device known to host file system signatures will be overwritten with zeros</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>full</doc:term>
              <doc:definition>Zeroes will be written out once on the device</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>full3pass</doc:term>
              <doc:definition>Writes random data on the device three times</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>full7pass</doc:term>
              <doc:definition>Writes random data on the device seven times</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>full35pass</doc:term>
              <doc:definition>Writes random data on the device 35 times</doc:definition>
            </doc:item>
          </doc:list>
          The data written out is not entirely random, see
          the <doc:ulink url="http://en.wikipedia.org/wiki/Gutmann_method">Gutmann
            Method</doc:ulink> for more details.
        </doc:para>
        <doc:para>
          A general note about properties: the set of values
          returned can be expected to grow in the future as both
          hardware and operating system capabilities evolve.  Care
          has been taken to namespace values so applications can
          properly fall back (see e.g.
          <doc:ref type="property" to="Device:drive-media-compatibility">drive-media-compatibility</doc:ref>)
          and export both general and specific properties (such as
          <doc:ref type="property" to="Device:id-usage">id-usage</doc:ref>
          vs.
          <doc:ref type="property" to="Device:id-type">id-type</doc:ref>).
          In general an empty string in a property means not
          set. Since the empty string is not a valid object path we
          use the "/" to mean "not set" for object paths.
        </doc:para>
      </doc:description>
    </doc:doc>

    <!-- ************************************************************ -->

    <method name="JobCancel">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>

      <doc:doc>
        <doc:description>
          <doc:para>
            Cancels a job in progress.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.cancel-job-others</doc:term>
              <doc:definition>To cancel a job initiated by another user</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_FAILED;">if no job is pending</doc:error>
          <doc:error name="&ERROR_NOT_CANCELLABLE;">if job is not cancellable</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="PartitionTableCreate">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="scheme" direction="in" type="s">
        <doc:doc><doc:summary>
            The scheme of the partition table to create.
        </doc:summary></doc:doc>
      </arg>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Supports the <doc:tt>erase=</doc:tt> option for erasing the contents of the device.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Creates a new partition table. The following partition table schemes are supported:
            <doc:list>
              <doc:item>
                <doc:term>none</doc:term>
                <doc:definition>To zero out existing partition tables signatures.</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>mbr</doc:term>
                <doc:definition>
                  Use the
                  <doc:ulink url="http://en.wikipedia.org/wiki/Master_Boot_Record">Master Boot Record</doc:ulink>
                  partitioning scheme.
                </doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>gpt</doc:term>
                <doc:definition>
                  Use the
                  <doc:ulink url="http://en.wikipedia.org/wiki/GUID_Partition_Table">GUID Partition Table</doc:ulink>
                  scheme.
                </doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>apm</doc:term>
                <doc:definition>
                  Use the
                  <doc:ulink url="http://en.wikipedia.org/wiki/Apple_Partition_Map">Apple Partition Map</doc:ulink>
                  partitioning scheme.
                </doc:definition>
              </doc:item>
            </doc:list>
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">non-system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change-system-internal</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device or a partition on it are busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="PartitionDelete">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Supports the <doc:tt>erase=</doc:tt> option for erasing the contents of the device.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Deletes a partition, removing it from the enclosing partition table.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">non-system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change-system-internal</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_PARTITION;">if the device is not a partition</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="PartitionCreate">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="offset" direction="in" type="t">
        <doc:doc><doc:summary>Where on the device to create the partition.</doc:summary></doc:doc>
      </arg>
      <arg name="size" direction="in" type="t">
        <doc:doc><doc:summary>Size of the partitition to create.</doc:summary></doc:doc>
      </arg>
      <arg name="type" direction="in" type="s">
        <doc:doc><doc:summary>
            The type of the partition to create. Valid types depends
            on the partitioning scheme used:
            <doc:list>
              <doc:item>
                <doc:term>mbr</doc:term>
                <doc:definition>
                  For the
                  <doc:ulink url="http://en.wikipedia.org/wiki/Master_Boot_Record">Master Boot Record</doc:ulink>
                  partitioning scheme, the
                  given type must be a string representation of an
                  integer (both decimal and hexadecimal encodings are
                  accepted) between 0 and 255 both inclusive.
                </doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>gpt</doc:term>
                <doc:definition>
                  Any valid GUID string.
                </doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>apm</doc:term>
                <doc:definition>
                  Any valid type for
                  <doc:ulink url="http://en.wikipedia.org/wiki/Apple_Partition_Map">Apple Partition Map</doc:ulink>
                  for example <doc:tt>Apple_Unix_SVR2</doc:tt>.
                </doc:definition>
              </doc:item>
            </doc:list>
        </doc:summary></doc:doc>
      </arg>
      <arg name="label" direction="in" type="s">
        <doc:doc><doc:summary>
            The label to use for the partition. Leave blank if the
            partition table scheme is <doc:tt>mbr</doc:tt>.
        </doc:summary></doc:doc>
      </arg>
      <arg name="flags" direction="in" type="as">
        <doc:doc><doc:summary>
            Flags to use for the partition. Valid flags depends on the
            partitioning scheme used:
            <doc:list>
              <doc:item>
                <doc:term>mbr</doc:term>
                <doc:definition>
                  Only the flag <doc:tt>boot</doc:tt> is valid.
                </doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>gpt</doc:term>
                <doc:definition>
                  Only the flag <doc:tt>required</doc:tt> is valid.
                </doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>apm</doc:term>
                <doc:definition>
                  The flags
                  <doc:tt>allocated</doc:tt>,
                  <doc:tt>in_use</doc:tt>,
                  <doc:tt>boot</doc:tt>,
                  <doc:tt>allow_read</doc:tt>,
                  <doc:tt>allow_write</doc:tt>,
                  <doc:tt>boot_code_is_pic</doc:tt>
                  are valid.
                </doc:definition>
              </doc:item>
            </doc:list>
        </doc:summary></doc:doc>
      </arg>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Currently unused.</doc:summary></doc:doc>
      </arg>
      <arg name="fstype" direction="in" type="s">
        <doc:doc><doc:summary>
            The file system to create in new partition. Leave
            blank to skip creating a file system. See the
            <doc:ref type="method" to="Device.FilesystemCreate">FilesystemCreate()</doc:ref> method
            for details.
        </doc:summary></doc:doc>
      </arg>
      <arg name="fsoptions" direction="in" type="as">
        <doc:doc><doc:summary>
            Options to use for file system creation. See the
            <doc:ref type="method" to="Device.FilesystemCreate">FilesystemCreate()</doc:ref> method
            for details.
        </doc:summary></doc:doc>
      </arg>
      <arg name="created_device" direction="out" type="o">
        <doc:doc><doc:summary>The object path of the newly added partition.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Create a new partition and, optionally, create a file
            system on it. The partition won't necessarily be created
            at the exact location requested due to disk geometry
            constraints.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">non-system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change-system-internal</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_PARTITION_TABLE;">if the device is not a partitition table</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="PartitionModify">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="type" direction="in" type="s">
        <doc:doc><doc:summary>
            The type of the partition to create. See the <doc:tt>type</doc:tt> parameter of the
            <doc:ref type="method" to="Device.PartitionCreate">PartitionCreate()</doc:ref> method
            for details on valid types.
        </doc:summary></doc:doc>
      </arg>
      <arg name="label" direction="in" type="s">
        <doc:doc><doc:summary>
            The label to use for the partition. See the <doc:tt>label</doc:tt> parameter of the
            <doc:ref type="method" to="Device.PartitionCreate">PartitionCreate()</doc:ref> method
            for details on valid labels.
        </doc:summary></doc:doc>
      </arg>
      <arg name="flags" direction="in" type="as">
        <doc:doc><doc:summary>
            Flags to use for the partition. See the <doc:tt>flags</doc:tt> parameter of the
            <doc:ref type="method" to="Device.PartitionCreate">PartitionCreate()</doc:ref> method
            for details on valid flags
        </doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Modifies meta data for a partition, such as type, label and flags.
            TODO: Consider allowing changing offset and
            size. Or maybe that should be a separate method.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">non-system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change-system-internal</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the enclosing partition table device is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_PARTITION;">if the device is not a partition</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="FilesystemCreate">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="fstype" direction="in" type="s">
        <doc:doc><doc:summary>
            The type of file system to
            create. Pass <doc:tt>empty</doc:tt> to not create a file
            system and just clear the areas of the device known to host
            file system signatures. Use @TODO@ to get a list of file systems that can
            be created.
        </doc:summary></doc:doc>
      </arg>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>
            Supports the <doc:tt>erase=</doc:tt> option for erasing the contents of the device. To set the
            label use <doc:tt>label=NAME</doc:tt>. Labels may not be supported
            for all file systems and the allowed length of a label may vary (see @TODO@).
            To create the file system on an LUKS encrypted
            block device, pass the <doc:tt>luks_encrypt=</doc:tt> option with the
            value set to the passphrase to use. For file systems with the concept of owners (e.g.
            <doc:tt>ext3</doc:tt>), the options <doc:tt>take_ownership_uid=</doc:tt> and
            <doc:tt>take_ownership_gid=</doc:tt> are supported and can be used to set the
            initial owner of the created file system.
        </doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Create a file system on a device. If
            the <doc:tt>luks_encrypt=</doc:tt> option is passed then an
            LUKS encrypted block device will be created, then unlocked and
            the file system will be created on the corresponding
            cleartext device.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">non-system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change-system-internal</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="FilesystemSetLabel">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="new_label" direction="in" type="s">
        <doc:doc><doc:summary>
            New label for file system.
        </doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Changes the file system label. See the <doc:tt>options</doc:tt> parameter of
            <doc:ref type="method"
            to="Device.FilesystemCreate">FilesystemCreate()</doc:ref>
            method for details of what valid labels are valid.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">non-system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change-system-internal</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is busy and changing the label requires an unmounted file system</doc:error>
          <doc:error name="&ERROR_FAILED;">if the file system doesn't support labels, the label is too long</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="FilesystemMount">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="filesystem_type" direction="in" type="s">
        <doc:doc><doc:summary>File system type to use.</doc:summary></doc:doc>
      </arg>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Mount Options. Valid mount options include mount options accepted by the native mount program.</doc:summary></doc:doc>
      </arg>
      <arg name="mount_path" direction="out" type="s">
        <doc:doc><doc:summary>Where the device was mounted.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Mount the device. If the device is referenced in the
            system-wide <doc:tt>/etc/fstab</doc:tt> file, the given
            parameters are all ignored and the device will be
            attempted to be mounted as the calling user.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.filesystem-mount</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">non-system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.filesystem-mount-system-internal</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_FILESYSTEM;">if the device is not a mountable file system</doc:error>
          <doc:error name="&ERROR_INVALID_OPTION;">if an invalid or malformed mount option was given</doc:error>
          <doc:error name="&ERROR_ALREADY_MOUNTED;">if the device is already mounted</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="FilesystemUnmount">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Unmount options. Valid options currently include only 'force'.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Unmount the device. If the device is referenced in the
            system-wide <doc:tt>/etc/fstab</doc:tt> file (both at
            mount time and when this method is invoked), the device
            will be attempted to be unmounted as the calling user.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.filesystem-unmount-others</doc:term>
              <doc:definition>To unmount a device mounted by another user</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_INVALID_OPTION;">if an invalid or malformed unmount option was given</doc:error>
          <doc:error name="&ERROR_NOT_MOUNTED;">if the device is not mounted</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="FilesystemCheck">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Currently unused.</doc:summary></doc:doc>
      </arg>
      <arg name="is_clean" direction="out" type="b">
        <doc:doc><doc:summary>
            Returns TRUE if the file system is clean, FALSE if there are errors on the file system.
        </doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Perform a non-interactive file system check.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.filesystem-check</doc:term>
              <doc:definition>To check a file system on a
                <doc:ref type="property" to="Device:device-is-system-internal">non-system-internal</doc:ref>
                device.</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.filesystem-check-system-internal</doc:term>
              <doc:definition>To check a file system on a
                <doc:ref type="property" to="Device:device-is-system-internal">system-internal</doc:ref>
                device.</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is mounted and the file system doesn't support online file system checking. See TODO for how to determine if a file system supports online fsck</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="FilesystemListOpenFiles">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="processes" direction="out" type="a(uus)">
        <doc:doc><doc:summary>
            An array of triples (<doc:tt>pid</doc:tt>, <doc:tt>uid</doc:tt>, command line for the process
            image) for processes currently having open files on the given mounted file system.
            Note that this operation is not run as a job.
        </doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            List open files on a mounted file system.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.filesystem-lsof</doc:term>
              <doc:definition>To check a file system on a
                <doc:ref type="property" to="Device:device-is-system-internal">non-system-internal</doc:ref>
                device.</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.filesystem-lsof-system-internal</doc:term>
              <doc:definition>To check a file system on a
                <doc:ref type="property" to="Device:device-is-system-internal">system-internal</doc:ref>
                device.</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is mounted and the file system doesn't support online file system checking. See TODO for how to determine if a file system supports online fsck</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_NOT_FILESYSTEM;">if the device is not a mountable file system</doc:error>
          <doc:error name="&ERROR_NOT_MOUNTED;">if the file system is not mounted</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="LuksUnlock">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="passphrase" direction="in" type="s">
        <doc:doc><doc:summary>Passphrase for unlocking the cleartext data.</doc:summary></doc:doc>
      </arg>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Currently unused.</doc:summary></doc:doc>
      </arg>
      <arg name="cleartext_device" direction="out" type="o">
        <doc:doc><doc:summary>The cleartext device created.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Sets up a cleartext device using the given device as backing store.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.luks-unlock</doc:term>
              <doc:definition>To unlock LUKS encrypted devices</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_LUKS;">if the device is not LUKS encrypted</doc:error>
          <doc:error name="&ERROR_NOT_LOCKED;">if the device is already unlocked</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="LuksLock">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Currently unused.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Tears down the cleartext device set up using
            e.g. the <doc:ref type="method"
            to="Device.LuksUnlock">LuksUnlock()</doc:ref>
            method.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.luks-lock-others</doc:term>
              <doc:definition>To lock an encrypted LUKS device unlocked by another user</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_LUKS;">if the device is not LUKS encrypted</doc:error>
          <doc:error name="&ERROR_NOT_UNLOCKED;">if the device is not unlocked</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="LuksChangePassphrase">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="current_passphrase" direction="in" type="s">
        <doc:doc><doc:summary>The current passphrase.</doc:summary></doc:doc>
      </arg>
      <arg name="new_passphrase" direction="in" type="s">
        <doc:doc><doc:summary>The new passphrase.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Change the passphrase used to unlock a LUKS encrypted device.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">non-system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.change-system-internal</doc:term>
              <doc:definition>If the operation is on a
                <doc:ref type="property" to="Device:device-is-system-internal">system-internal</doc:ref>
                device</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_LUKS;">if the device is not LUKS encrypted</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="LinuxMdAddComponent">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="component" direction="in" type="o">
        <doc:doc><doc:summary>Object path of the component to add</doc:summary></doc:doc>
      </arg>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Currently unused.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Adds a component to a Linux md RAID array. Existing data
            on the given component will be erased.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need the following PolicyKit authorization:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.linux-md</doc:term>
              <doc:definition>
                Needed to configured Linux md Software RAID devices.
              </doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">component to add is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_LINUX_MD;">device to add component to is not a Linux md RAID array</doc:error>
          <doc:error name="&ERROR_NOT_FOUND;">given component doesn't exist</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="LinuxMdRemoveComponent">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="component" direction="in" type="o">
        <doc:doc><doc:summary>The component to remove from the array.</doc:summary></doc:doc>
      </arg>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Supports the <doc:tt>erase=</doc:tt> option for erasing the contents of the device.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Removes a component from a Linux md RAID array. The component
            will be removed and then the signatures on the component will be
            erased according to the erase= option.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need the following PolicyKit authorization:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.linux-md</doc:term>
              <doc:definition>
                Needed to configured Linux md Software RAID devices.
              </doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">component to add is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_LINUX_MD;">device to remove component from is not a Linux md RAID array</doc:error>
          <doc:error name="&ERROR_NOT_FOUND;">given component is not part of the array</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="LinuxMdStop">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Currently unused.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Stops a Linux md RAID array.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need the following PolicyKit authorization:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.linux-md</doc:term>
              <doc:definition>
                Needed to configured Linux md Software RAID devices.
              </doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">component to add is busy</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_LINUX_MD;">device is not a Linux md RAID array</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="DriveInhibitPolling">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Inhibit options. Currently no options are recognized.</doc:summary></doc:doc>
      </arg>

      <arg name="cookie" direction="out" type="s">
        <doc:doc><doc:summary>
            A cookie that can be used in the
            <doc:ref type="method" to="Device.DriveUninhibitPolling">DriveUninhibitPolling()</doc:ref> method
            to stop inhibiting polling of the device.
        </doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Inhibits the daemon from polling the device for media changes.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.inhibit-polling</doc:term>
              <doc:definition>To inhibit polling</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_NOT_DRIVE;">device is not a drive</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="DriveUninhibitPolling">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>

      <arg name="cookie" direction="in" type="s">
        <doc:doc><doc:summary>
            A cookie obtained from the
            <doc:ref type="method" to="Device.DriveInhibitPolling">DriveInhibitPolling()</doc:ref> method.
        </doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Uninhibits daemon from polling the device for media changes.
          </doc:para>
        </doc:description>
        <doc:errors>
          <doc:error name="&ERROR_FAILED;">if the given cookie is malformed</doc:error>
        </doc:errors>
      </doc:doc>
    </method>


    <!-- ************************************************************ -->

    <method name="DrivePollMedia">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>

      <doc:doc>
        <doc:description>
          <doc:para>
            Polls the drive for media. This is typically only useful when the
            <doc:ref type="property" to="Device:device-is-media-change-detected">device-is-media-change-detected</doc:ref> property
            is FALSE.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.inhibit-polling</doc:term>
              <doc:definition>To inhibit polling</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_FAILED;">if an unknown error occured</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="DriveEject">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Eject options. Currently no options are recognized.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Ejects media from the device.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.drive-eject</doc:term>
              <doc:definition>To eject media from a device</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_BUSY;">if the device or a dependent device (e.g. partition or cleartext luks device) is busy (e.g. mounted)</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_NOT_DRIVE;">device is not a drive</doc:error>
          <doc:error name="&ERROR_INVALID_OPTION;">if an invalid or malformed unmount option was given</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="DriveAtaSmartRefreshData">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>
            The option <doc:tt>nowakeup</doc:tt> can be passed to
            avoid spinning up the disk if it's in a low-power mode.
            The option <doc:tt>simulate=</doc:tt> can be
            passed to use the given string (which is in a format private to DeviceKit-disks) instead
            of reading it from the disk.
            The <doc:tt>simulate=</doc:tt> option can only be used by the super user.
        </doc:summary></doc:doc>
      </arg>
      <doc:doc>
        <doc:description>
          <doc:para>
            Refreshes the
            <doc:ulink url="http://en.wikipedia.org/wiki/S.M.A.R.T">ATA SMART</doc:ulink>
            data for the given drive. Note that this operation is not run as a job.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.drive-ata-smart-refresh</doc:term>
              <doc:definition>Needed to refresh ATA SMART data</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_ATA_SMART_NOT_AVAILABLE;">if ATA SMART isn't available on the disk</doc:error>
          <doc:error name="&ERROR_ATA_SMART_WOULD_WAKEUP;">If the disk is asleep and the nowakeup option was passed</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="DriveAtaSmartGetHistoricalData">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
      <arg name="since" direction="in" type="t">
        <doc:doc><doc:summary>
            Don't fetch data collected earlier than this point
            in time (seconds since the Epoch Jan 1, 1970 0:00 UTC).
        </doc:summary></doc:doc>
      </arg>
      <arg name="until" direction="in" type="t">
        <doc:doc><doc:summary>
            Don't fetch data collected later than this point in
            time (seconds since the Epoch Jan 1, 1970 0:00 UTC). If 0 is
            passed the current time will be used.
        </doc:summary></doc:doc>
      </arg>
      <arg name="data" direction="out" type="a(tbbbbdta(usubbybybybbbutay))">
        <doc:doc><doc:summary>
            An array of historical data. Each element contains
            the following members (TODO).
        </doc:summary></doc:doc>
      </arg>
      <doc:doc>
        <doc:description>
          <doc:para>
            Retrieves historical ATA SMART data from the drive in the
            given time interval. Note that this is data collected and
            stored by the host as ATA SMART capable devices cannot
            store or return historical data by themselves.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.drive-ata-smart-retrieve-historical-data</doc:term>
              <doc:definition>To retrieve historical ATA SMART data</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_ATA_SMART_NOT_AVAILABLE;">if ATA SMART isn't available on the disk</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <method name="DriveAtaSmartInitiateSelftest">
      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>

      <arg name="test" direction="in" type="s">
        <doc:doc><doc:summary>
            The name of the test to run; supported values are 'short'
            (usually less than ten minutes), 'extended' (usually tens
            of minutes) and 'conveyance' (usually a few minutes).
        </doc:summary></doc:doc>
      </arg>
      <arg name="options" direction="in" type="as">
        <doc:doc><doc:summary>Currently unused.</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Runs a ATA SMART self test on the drive.
          </doc:para>
        </doc:description>
        <doc:permission>
          The caller will need one of the following PolicyKit authorizations:
          <doc:list>
            <doc:item>
              <doc:term>org.freedesktop.devicekit.disks.drive-ata-smart-selftest</doc:term>
              <doc:definition>Needed to run ATA SMART self tests</doc:definition>
            </doc:item>
          </doc:list>
        </doc:permission>
        <doc:errors>
          <doc:error name="&ERROR_NOT_AUTHORIZED;">if the caller lacks the appropriate PolicyKit authorization</doc:error>
          <doc:error name="&ERROR_FAILED;">if incoming parameters are invalid or an unknown error occured</doc:error>
          <doc:error name="&ERROR_CANCELLED;">if the job was cancelled</doc:error>
          <doc:error name="&ERROR_ATA_SMART_NOT_AVAILABLE;">device is not ATA SMART capable</doc:error>
        </doc:errors>
      </doc:doc>
    </method>

    <!-- ************************************************************ -->

    <signal name="Changed">
      <doc:doc>
        <doc:description>
          <doc:para>
            Something on the device changed. Changes in job state wont
            trigger this signal; see the <doc:ref type="signal"
            to="Device::JobChanged">JobChanged()</doc:ref> signal.
          </doc:para>
        </doc:description>
      </doc:doc>
    </signal>

    <!-- ************************************************************ -->

    <signal name="JobChanged">
      <arg name="job-in-progress" type="b">
        <doc:doc><doc:summary>Whether a job is currently in progress.</doc:summary></doc:doc>
      </arg>
      <arg name="job-is-cancellable" type="b">
        <doc:doc><doc:summary>Whether the job is cancellable.</doc:summary></doc:doc>
      </arg>
      <arg name="job-id" type="s">
        <doc:doc><doc:summary>The identifier of the job.</doc:summary></doc:doc>
      </arg>
      <arg name="job-initiated-by-uid" type="u">
        <doc:doc><doc:summary>The UNIX user id of the user who initiated the job.</doc:summary></doc:doc>
      </arg>
      <arg name="job-num-tasks" type="i">
        <doc:doc><doc:summary>Number of tasks in the job or zero if unknown.</doc:summary></doc:doc>
      </arg>
      <arg name="job-cur-task" type="i">
        <doc:doc><doc:summary>Current task number (zero-based offset).</doc:summary></doc:doc>
      </arg>
      <arg name="job-cur-task-id" type="s">
        <doc:doc><doc:summary>Task identifier for current task.</doc:summary></doc:doc>
      </arg>
      <arg name="job-cur-task-percentage" type="d">
        <doc:doc><doc:summary>Percentage completed of current task (between 0 and 100, negative if unknown).</doc:summary></doc:doc>
      </arg>

      <doc:doc>
        <doc:description>
          <doc:para>
            Emitted when a job on a device changes. Clients should
            listen to this signal to avoid polling the daemon for job
            state.
          </doc:para>
        </doc:description>
      </doc:doc>
    </signal>

    <!-- ************************************************************ -->

    <property name="native-path" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            OS specific native path of the device. On Linux this is the sysfs path, for example <doc:tt>/sys/devices/pci0000:00/0000:00:1f.2/host2/target2:0:1/2:0:1:0/block/sda</doc:tt>.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-major" type="x" access="read">
      <doc:doc><doc:description><doc:para>
            Major for the device or -1 if not set.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-minor" type="x" access="read">
      <doc:doc><doc:description><doc:para>
            Major for the device or -1 if not set.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-file" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            UNIX special device file for device. Example: <doc:tt>/dev/sda</doc:tt>.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-file-by-id" type="as" access="read">
      <doc:doc><doc:description><doc:para>
            Symlinks to UNIX special device file that are stable and uniquely identifies the device.
            Example: <doc:tt>/dev/disk/by-id/scsi-SATA_ST910021AS_3MH05AVA</doc:tt>,
            <doc:tt>/dev/disk/by-id/ata-ST910021AS_3MH05AVA</doc:tt>.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-file-by-path" type="as" access="read">
      <doc:doc><doc:description><doc:para>
            Symlinks to UNIX special device file that uniquely identifies the port/partition the device
            is plugged into. Example: <doc:tt>/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:1:0</doc:tt>
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-system-internal" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if the device is considered system internal. Typically, system internal devices
            include non-removable internal hard disks and other drives that are not easily added/removed
            by a local console user. The heuristic typically used is that only devices on removable media
            and devices connected via Firewire, USB, eSATA and SDIO are considered external.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-partition" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if the device is a partition. See the properties starting with partition- for details.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-partition-table" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if the device contains a partition table. See partition- properties for details.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-removable" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if the device contains removable media.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-media-available" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if media is available in the device.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-media-change-detected" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if media changes are detected.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-media-change-detection-polling" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if media changes are detected through the host
            polling the device, e.g. waking up every two seconds to
            revalidate the media. This typically keeps the device in a
            high power state and uses cycles on the CPU. As an
            example, SATA AN capable optical drives does not need
            polling.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-media-change-detection-inhibitable" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if it is possible to inhibit media detection on the device (to avoid keeping the device in a high power state and waking up the host).
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-media-change-detection-inhibited" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if media detection is inhibited (to avoid keeping the device in a high power state and waking up the host).
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-read-only" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if the device read-only.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-drive" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if the device is a drive.
            See the drive- properties for details.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-optical-disc" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if the device is an optical drive and an optical disc is inserted.
            See the optical-disc- properties for details.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-mounted" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if the device is mounted.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-mount-paths" type="as" access="read">
      <doc:doc><doc:description><doc:para>
            A list of paths in the root namespace where the root of the device is mounted.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-mounted">device-is-mounted</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-mounted-by-uid" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            The UNIX user id of the user who mounted the device. Set to 0 if
            not mounted by DeviceKit-disks.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-mounted">device-is-mounted</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-luks" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if device is an LUKS encrypted device. See luks- properties for details.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-luks-cleartext" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if device is a cleartext device backed by a LUKS encrypted device. See luks-cleartext- properties for details.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-linux-md-component" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if the device is a Linux md RAID component. See linux-md-component- properties for details.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-is-linux-md" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE if the device is a Linux md RAID array. See linux-md- properties for details.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-size" type="t" access="read">
      <doc:doc><doc:description><doc:para>
            The size of the device in bytes.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-block-size" type="t" access="read">
      <doc:doc><doc:description><doc:para>
            The block size of the device in bytes.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-presentation-name" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The name to use when presenting the device to an end user.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="device-presentation-icon-name" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The icon to use when presenting the device to an end user. If set, must be a name
            following the freedesktop.org icon theme specification.
      </doc:para></doc:description></doc:doc>
    </property>

    <property name="job-in-progress" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            The job properties specify if a job initiated via the
            DeviceKit-disks daemon is currently in progress.  A job
            may be split into several sequential tasks; in that case
            <doc:ref type="property" to="Device:job-num-tasks">job-num-tasks</doc:ref>
            will be greater than one.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="job-id" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            This property is used to identify the job and maps 1-1
            with the names of the method calls on this interface,
            e.g. 'Erase', 'FilesystemCreate' and so on.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="job-initiated-by-uid" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            The UNIX user id of the user who initiated the job.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="job-is-cancellable" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            Whether the job can be cancelled
            using <doc:ref type="method"
            to="Device.JobCancel">JobCancel()</doc:ref> method.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="job-num-tasks" type="i" access="read">
      <doc:doc><doc:description><doc:para>
            Number of tasks in the job..
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="job-cur-task" type="i" access="read">
      <doc:doc><doc:description><doc:para>
            Current task number (zero-based offset).
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="job-cur-task-id" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            Task identifier for current task. TODO: enumerate task id's.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="job-cur-task-percentage" type="d" access="read">
      <doc:doc><doc:description><doc:para>
            Percentage completed of current task (between 0 and 100, negative if unknown).
      </doc:para></doc:description></doc:doc>
    </property>

    <property name="id-usage" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            A result of probing for signatures on the block device;
            known values are:
            <doc:list>
              <doc:item>
                <doc:term>filesystem</doc:term>
                <doc:definition>A mountable file system was detected</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>crypto</doc:term>
                <doc:definition>Encrypted data (e.g. LUKS) was detected</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>partitiontable</doc:term>
                <doc:definition>A partition table was detected</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>raid</doc:term>
                <doc:definition>Used for RAID and LVM components</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>other</doc:term>
                <doc:definition>A non-standard signature was detected</doc:definition>
              </doc:item>
            </doc:list>
            If blank, no known signature was detected. This doesn't
            necessarily mean the device contains no structured data;
            it only means that no signature known to the probing code
            was detected.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="id-type" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            This property contains more information about the result
            of probing the block device. It's value depends of the
            value the
            <doc:ref type="property" to="Device:id-usage">id-usage</doc:ref>
            property:
            <doc:list>
              <doc:item>
                <doc:term>filesystem</doc:term>
                <doc:definition>The mountable file system that was detected (e.g. <doc:tt>ext3</doc:tt>, <doc:tt>vfat</doc:tt>)</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>crypto</doc:term>
                <doc:definition>Known values include <doc:tt>crypto_LUKS</doc:tt></doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>partitiontable</doc:term>
                <doc:definition>
                  Known values include
                  <doc:tt>mbr</doc:tt> (for the
                  <doc:ulink url="http://en.wikipedia.org/wiki/Master_Boot_Record">Master Boot Record</doc:ulink>
                  scheme),
                  <doc:tt>gpt</doc:tt> (for the
                  <doc:ulink url="http://en.wikipedia.org/wiki/GUID_Partition_Table">GUID Partition Table</doc:ulink>
                  scheme),
                  <doc:tt>apm</doc:tt> (for the
                  <doc:ulink url="http://en.wikipedia.org/wiki/Apple_Partition_Map">Apple Partition Map</doc:ulink>
                  scheme).
                </doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>raid</doc:term>
                <doc:definition>
                  Known values include
                  <doc:tt>LVM1_member</doc:tt> (for Linux LVM1 components),
                  <doc:tt>LVM2_member</doc:tt> (for Linux LVM2 components),
                  <doc:tt>linux_raid_member</doc:tt> (for Linux md (Software RAID) components)
                </doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>other</doc:term>
                <doc:definition>
                  Known values include
                  <doc:tt>swap</doc:tt> (for swap space),
                  <doc:tt>suspend</doc:tt> (data used when resuming from STD)
                </doc:definition>
              </doc:item>
            </doc:list>
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="id-version" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The version of the
            detected file system (or other identified data structure) identified by the
            <doc:ref type="property" to="Device:id-usage">id-usage</doc:ref>
            and
            <doc:ref type="property" to="Device:id-usage">id-type</doc:ref>
            properties.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="id-uuid" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The UUID (universally unique identifier) of the
            detected file system (or other identified data structure) identified by the
            <doc:ref type="property" to="Device:id-usage">id-usage</doc:ref>
            and
            <doc:ref type="property" to="Device:id-usage">id-type</doc:ref>
            properties.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="id-label" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The user-visible label of the
            detected file system (or other identified data structure) identified by the
            <doc:ref type="property" to="Device:id-usage">id-usage</doc:ref>
            and
            <doc:ref type="property" to="Device:id-usage">id-type</doc:ref>
            properties.
      </doc:para></doc:description></doc:doc>
    </property>

    <property name="luks-holder" type="o" access="read">
      <doc:doc><doc:description><doc:para>
            The cleartext device that is using the LUKS device.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-luks-cleartext">device-is-luks</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>

    <property name="luks-cleartext-slave" type="o" access="read">
      <doc:doc><doc:description><doc:para>
            The encrypted LUKS device backing a crypto cleartext device.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-luks-cleartext">device-is-luks-cleartext</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="luks-cleartext-unlocked-by-uid" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            The UNIX user id of the user who unlocked the LUKS device. Set to 0 if
            not unlocked by DeviceKit-disks.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-luks-cleartext">device-is-luks-cleartext</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>

    <property name="partition-slave" type="o" access="read">
      <doc:doc><doc:description><doc:para>
            The object path of the partition table the partition is part of.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition">device-is-partition</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="partition-scheme" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The scheme of the partition table this partition is part of.
            See the <doc:tt>scheme</doc:tt> parameter of the
            <doc:ref type="method" to="Device.PartitionTableCreate">PartitionTableCreate()</doc:ref> method
            for details on known partitioning schemes.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition">device-is-partition</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="partition-type" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The type of the partition.
            See the <doc:tt>type</doc:tt> parameter of the
            <doc:ref type="method" to="Device.PartitionCreate">PartitionCreate()</doc:ref> method
            for details on known partitioning types.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition">device-is-partition</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="partition-label" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The label of the partition.
            See the <doc:tt>label</doc:tt> parameter of the
            <doc:ref type="method" to="Device.PartitionCreate">PartitionCreate()</doc:ref> method
            for details on partition labels.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition">device-is-partition</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="partition-uuid" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The UUID of the partition.
            See the <doc:tt>uuid</doc:tt> parameter of the
            <doc:ref type="method" to="Device.PartitionCreate">PartitionCreate()</doc:ref> method
            for details on partition UUID's.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition">device-is-partition</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="partition-flags" type="as" access="read">
      <doc:doc><doc:description><doc:para>
            Partition flags.
            See the <doc:tt>flags</doc:tt> parameter of the
            <doc:ref type="method" to="Device.PartitionCreate">PartitionCreate()</doc:ref> method
            for details on partition flags.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition">device-is-partition</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="partition-number" type="i" access="read">
      <doc:doc><doc:description><doc:para>
            Number of the partition. Typically partition numbers start at 1 and are identical
            to the numbers used by the kernel. Note that partitions may not be sequentially
            numbered.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition">device-is-partition</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="partition-offset" type="t" access="read">
      <doc:doc><doc:description><doc:para>
            Offset in bytes where the partition is located on the enclosing partition table device (see
            <doc:ref type="property" to="Device:device-is-partition">partition-slave</doc:ref>).
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition">device-is-partition</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="partition-size" type="t" access="read">
      <doc:doc><doc:description><doc:para>
            Size of the partition in bytes.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition">device-is-partition</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>

    <property name="partition-table-scheme" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The scheme of the partition table.
            See the <doc:tt>scheme</doc:tt> parameter of the
            <doc:ref type="method" to="Device.PartitionTableCreate">PartitionTableCreate()</doc:ref> method
            for details on known partitioning schemes.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition-table">device-is-partition-table</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="partition-table-count" type="i" access="read">
      <doc:doc><doc:description><doc:para>
            Number of partitions in the partition table.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-partition-table">device-is-partition-table</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>

    <property name="drive-vendor" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            Name of the vendor of the drive, for example <doc:tt>MATSHITA</doc:tt> or <doc:tt>BELKIN</doc:tt>.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-drive">device-is-drive</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-model" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            Name of the model of the drive, for example <doc:tt>ST910021AS</doc:tt> or <doc:tt>USB 2 HS-CF</doc:tt>.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-drive">device-is-drive</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-revision" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            Revision of the drive, for example <doc:tt>3.07</doc:tt> or <doc:tt>1.95</doc:tt>.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-drive">device-is-drive</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-serial" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The serial number of the drive or blank if unknown.
            Examples: <doc:tt>3MH05AVA</doc:tt>, <doc:tt>A0000001B900</doc:tt>.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-drive">device-is-drive</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-connection-interface" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The interface through which the drive is connected. Known values include:

            <doc:list type="bullet">
              <doc:item>
                <doc:term>virtual</doc:term>
                <doc:definition>Device is a composite device e.g. Software RAID or similar</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>ata</doc:term>
                <doc:definition>Connected via ATA</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>ata_serial</doc:term>
                <doc:definition>Connected via Serial ATA</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>ata_serial_esata</doc:term>
                <doc:definition>Connected via eSATA</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>ata_parallel</doc:term>
                <doc:definition>Connected via Parallel ATA</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>scsi</doc:term>
                <doc:definition>Connected via SCSI</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>usb</doc:term>
                <doc:definition>Connected via the Universal Serial Bus</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>firewire</doc:term>
                <doc:definition>Connected via Firewire</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>sdio</doc:term>
                <doc:definition>Connected via SDIO</doc:definition>
              </doc:item>
            </doc:list>
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-drive">device-is-drive</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-connection-speed" type="t" access="read">
      <doc:doc><doc:description><doc:para>
            The nominal speed of the connection interface in bits per
            second. If unknown this property is set to 0.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-drive">device-is-drive</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-media-compatibility" type="as" access="read">
      <doc:doc><doc:description><doc:para>
            An array of media types that can be used in the
            drive. This property is sometimes set using quirk files if
            the hardware isn't capable of precisely reporting it.
            Known values include:
            <doc:list>
              <doc:item>
                <doc:term>flash</doc:term>
                <doc:definition>Flash Card</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>flash_cf</doc:term>
                <doc:definition>CompactFlash</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>flash_ms</doc:term>
                <doc:definition>MemoryStick</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>flash_sm</doc:term>
                <doc:definition>SmartMedia</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>flash_sd</doc:term>
                <doc:definition>Secure Digital</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>flash_sdhc</doc:term>
                <doc:definition>Secure Digital High-Capacity</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>flash_mmc</doc:term>
                <doc:definition>MultiMediaCard</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>floppy</doc:term>
                <doc:definition>Floppy Disk</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>floppy_zip</doc:term>
                <doc:definition>Zip Disk</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>floppy_jaz</doc:term>
                <doc:definition>Jaz Disk</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical</doc:term>
                <doc:definition>Optical Disc</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_cd</doc:term>
                <doc:definition>Compact Disc</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_cd_r</doc:term>
                <doc:definition>Compact Disc Recordable</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_cd_rw</doc:term>
                <doc:definition>Compact Disc Rewritable</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_dvd</doc:term>
                <doc:definition>Digital Versatile Disc</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_dvd_r</doc:term>
                <doc:definition>DVD-R</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_dvd_rw</doc:term>
                <doc:definition>DVD-RW</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_dvd_ram</doc:term>
                <doc:definition>DVD-RAM</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_dvd_plus_r</doc:term>
                <doc:definition>DVD+R</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_dvd_plus_rw</doc:term>
                <doc:definition>DVD+RW</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_dvd_plus_r_dl</doc:term>
                <doc:definition>DVD+R Dual Layer</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_dvd_plus_rw_dl</doc:term>
                <doc:definition>DVD+RW Dual Layer</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_bd</doc:term>
                <doc:definition>Bluray Disc</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_bd_r</doc:term>
                <doc:definition>BluRay Recordable</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_bd_re</doc:term>
                <doc:definition>BluRay Rewritable</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_hddvd</doc:term>
                <doc:definition>HD DVD</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_hddvd_r</doc:term>
                <doc:definition>HD DVD Recordable</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_hddvd_rw</doc:term>
                <doc:definition>HD DVD Rewritable</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_mo</doc:term>
                <doc:definition>Magneto Optical</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_mrw</doc:term>
                <doc:definition>Can read Mount Rainer media</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>optical_mrw_w</doc:term>
                <doc:definition>Can write Mount Rainer media</doc:definition>
              </doc:item>
            </doc:list>
          </doc:para><doc:para>
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-drive">device-is-drive</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-media" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The type of media currently in the drive (blank if no media is available). Known
            values include the ones listed for the
            <doc:ref type="property" to="Device:drive-media-compatibility">drive-media-compatibility</doc:ref>
            property.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-drive">device-is-drive</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-is-media-ejectable" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE only if the media can be physically ejected by issuing a command
            from the host to the drive (e.g. optical drives). For devices, like iPod's,
            that require an eject ioctl to be sent in order to be safely removed, use the
            <doc:ref type="property" to="Device:drive-requires-eject">drive-requires-eject</doc:ref>
            property instead.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-drive">device-is-drive</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-requires-eject" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE only if the drive requires an eject ioctl to be safely removed; typically
            this includes multimedia devices like the iPod. If media can be physically
            ejected from the drive, use the
            <doc:ref type="property" to="Device:drive-is-media-ejectable">drive-is-media-ejectable</doc:ref>
            property instead.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-drive">device-is-drive</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>

    <property name="optical-disc-is-blank" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE only if the disc is appendable.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-optical-disc">device-is-optical-disc</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="optical-disc-is-appendable" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE only if the disc is appendable.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-optical-disc">device-is-optical-disc</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="optical-disc-is-closed" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE only if the disc is appendable.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-optical-disc">device-is-optical-disc</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="optical-disc-num-tracks" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            Number of tracks on the disc.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-optical-disc">device-is-optical-disc</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="optical-disc-num-audio-tracks" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            Number of audio tracks on the disc.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-optical-disc">device-is-optical-disc</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="optical-disc-num-sessions" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            Number of sessions on the disc.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-optical-disc">device-is-optical-disc</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>

    <!-- **************************************************************************************************** -->

    <property name="drive-ata-smart-is-available" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE only if drive is capable of reporting
            <doc:ulink url="http://en.wikipedia.org/wiki/S.M.A.R.T">ATA SMART</doc:ulink>
            data.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-is-failing" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            Set to TRUE if ATA SMART indicates that the disk is failing, TRUE otherwise.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero and the property
            <doc:ref type="property" to="Device:drive-ata-smart-status-valid">drive-ata-smart-status-valid</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-is-failing-valid" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            Set to TRUE only if the property
            <doc:ref type="property" to="Device:drive-ata-smart-status">drive-ata-smart-status</doc:ref>
            is valid.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-has-bad-sectors" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            Set to TRUE if ATA SMART indicates that one or more sectors are bad, TRUE otherwise.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-has-bad-attributes" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            Set to TRUE if ATA SMART indicates that one or more attributes are exceeding their threshold, TRUE otherwise.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-temperature-kelvin" type="d" access="read">
      <doc:doc><doc:description><doc:para>
            Temperature of the drive in kelvin or 0 if unknown.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-power-on-seconds" type="t" access="read">
      <doc:doc><doc:description><doc:para>
            Seconds the drive has been powered on or 0 if unknown.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-time-collected" type="t" access="read">
      <doc:doc><doc:description><doc:para>
            The point in time (seconds since the Epoch Jan 1, 1970
            0:00 UTC) when ATA SMART data was collected. If data
            was never collected, this property will assume the value
            0.  This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-is-available">drive-ata-smart-is-available</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-offline-data-collection-status" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            Offline data collection status (TODO: specify values).
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-offline-data-collection-seconds" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            Number of seconds needed to perform offline data collection status.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-self-test-execution-status" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            Current status of self test (TODO: specify values).
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-self-test-execution-percent-remaining" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            The progress of an ongoing self test or 0 if no self test is in progress.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-short-and-extended-self-test-available" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            Whether the short and extended self-tests are available.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-conveyance-self-test-available" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            Whether the conveyance self-test is available.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-start-self-test-available" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            Whether the start self-test is available.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-abort-self-test-available" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            Whether the abort self-test is available.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>

    <property name="drive-ata-smart-short-self-test-polling-minutes" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            Recommended polling time in minutes for short self-test.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-extended-self-test-polling-minutes" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            Recommended polling time in minutes for extended self-test.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-conveyance-self-test-polling-minutes" type="u" access="read">
      <doc:doc><doc:description><doc:para>
            Recommended polling time in minutes for conveyance self-test.
            This property is only valid if
            <doc:ref type="property" to="Device:drive-ata-smart-time-collected">drive-ata-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="drive-ata-smart-attributes" type="a(usubbybybybbbutay)" access="read">
      <doc:doc><doc:description><doc:para>
            An array of ATA SMART attributes. Each element contains the following members (TODO).
            This property is only valid if
            <doc:ref type="property" to="Device:drive-smart-time-collected">drive-smart-time-collected</doc:ref>
            is greater than zero.
      </doc:para></doc:description></doc:doc>
    </property>

    <!-- **************************************************************************************************** -->

    <property name="linux-md-component-level" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The RAID level of the array the component is part of. Known values include
            <doc:list>
              <doc:item>
                <doc:term>linear</doc:term>
                <doc:definition>The array is Just A Bunch of Disks</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>raid0</doc:term>
                <doc:definition>RAID-0</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>raid1</doc:term>
                <doc:definition>RAID-1</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>raid4</doc:term>
                <doc:definition>RAID-4</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>raid5</doc:term>
                <doc:definition>RAID-5</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>raid10</doc:term>
                <doc:definition>RAID-10</doc:definition>
              </doc:item>
            </doc:list>
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md-component">device-is-linux-md-component</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-component-num-raid-devices" type="i" access="read">
      <doc:doc><doc:description><doc:para>
            The number of component devices in the array the component is part of.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md-component">device-is-linux-md-component</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-component-uuid" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The UUID of the array the component is part of.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md-component">device-is-linux-md-component</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-component-name" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The name of the array the component is part of. Blank if the array
            doesn't have a name (e.g. pre-1.0 meta data).
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md-component">device-is-linux-md-component</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-component-home-host" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The home host of the array the component is part of, e.g. where it was created. Blank if the array
            has pre-1.0 meta data.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md-component">device-is-linux-md-component</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-component-version" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The version of superblock of the component.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md-component">device-is-linux-md-component</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-component-holder" type="o" access="read">
      <doc:doc><doc:description><doc:para>
            The holder of the component or "/" if the component isn't claimed by any array.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md-component">device-is-linux-md-component</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-component-state" type="as" access="read">
      <doc:doc><doc:description><doc:para>
            The state of the component (contents of <literal>md/dev-XXX/state</literal> file).
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md-component">device-is-linux-md-component</doc:ref>
            is TRUE and
            <doc:ref type="property" to="Device:device-is-linux-md-component-holder">device-is-linux-md-component-holder</doc:ref>
            is non-empty.
      </doc:para></doc:description></doc:doc>
    </property>

    <property name="linux-md-state" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The state of the array (contents of the <literal>md/array_state</literal> file).
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-level" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The RAID level of the array. For known values see the
            <doc:ref type="property" to="Device:linux-md-component-level">linux-md-component-level</doc:ref>
            property.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-uuid" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The UUID of the array.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-home-host" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The home host of the array, e.g. where if was created. Blank if the array
            has pre-1.0 meta data.
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-name" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The name of the array. Blank if the array
            doesn't have a name (e.g. pre-1.0 meta data).
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-num-raid-devices" type="i" access="read">
      <doc:doc><doc:description><doc:para>
            Number of component devices in the array.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-version" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            Metadata version used in the components.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-slaves" type="ao" access="read">
      <doc:doc><doc:description><doc:para>
            An array of object paths for components currently part of the array.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-is-degraded" type="b" access="read">
      <doc:doc><doc:description><doc:para>
            TRUE only if the array is running in degraded mode.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-sync-action" type="s" access="read">
      <doc:doc><doc:description><doc:para>
            The operation currently pending on the array. Known values
            include
            <doc:list>
              <doc:item>
                <doc:term>idle</doc:term>
                <doc:definition>No operation is pending</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>reshape</doc:term>
                <doc:definition>A reshape is in progress</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>resync</doc:term>
                <doc:definition>Redudancy is being calculated</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>repair</doc:term>
                <doc:definition>A repair operation is in progress</doc:definition>
              </doc:item>
              <doc:item>
                <doc:term>recover</doc:term>
                <doc:definition>A hot spare is being built to replace a failed/missing device</doc:definition>
              </doc:item>
            </doc:list>
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-sync-percentage" type="d" access="read">
      <doc:doc><doc:description><doc:para>
            The progress of the current sync operation.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE and the value of the property
            <doc:ref type="property" to="Device:linux-md-sync-action">linux-md-sync-action</doc:ref>
            is not <doc:tt>idle</doc:tt>.
      </doc:para></doc:description></doc:doc>
    </property>
    <property name="linux-md-sync-speed" type="t" access="read">
      <doc:doc><doc:description><doc:para>
            The speed of the sync operation in bytes per second.
            This property is only valid if
            <doc:ref type="property" to="Device:device-is-linux-md">device-is-linux-md</doc:ref>
            is TRUE and the value of the property
            <doc:ref type="property" to="Device:linux-md-sync-action">linux-md-sync-action</doc:ref>
            is not <doc:tt>idle</doc:tt>.
      </doc:para></doc:description></doc:doc>
    </property>

  </interface>

</node>
